#!/usr/bin/env node

const axios = require('axios');

const BASE_URL = 'http://localhost:3333';
const TEST_DATA = {
  practitioner: 'fabiangc@gmail.com',
  patient: '00636525872',
  organization: 'ORG-000006',
  location: '126'
};

async function createTestInProgressEncounter() {
  try {
    console.log('ğŸš€ Starting test encounter creation workflow...\n');

    // Step 1: Login
    console.log('ğŸ” Step 1: Logging in...');
    const loginResponse = await axios.post(`${BASE_URL}/login`, {
      username: 'fabiangc@gmail.com',
      password: 'senha2'
    });
    
    const token = loginResponse.data.token;
    console.log('âœ… Login successful');
    
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
      'managingorg': TEST_DATA.organization,
      'practid': TEST_DATA.practitioner
    };

    // Step 2: Get required reference data (like frontend does)
    console.log('\nğŸ“‹ Step 2: Getting reference data...');
    
    // Get service categories
    const serviceCategoriesResponse = await axios.get(
      `${BASE_URL}/pract/getpractservicecategories/${TEST_DATA.practitioner}`,
      { headers }
    );
    const serviceCategories = serviceCategoriesResponse.data || [];
    const firstServiceCategory = serviceCategories[0]?.id || '1';
    
    // Get service types  
    const serviceTypesResponse = await axios.get(
      `${BASE_URL}/pract/getpractservicetypes/${TEST_DATA.practitioner}`,
      { headers }
    );
    const serviceTypes = serviceTypesResponse.data || [];
    const firstServiceType = serviceTypes[0]?.id || '1';
    
    console.log(`âœ… Found ${serviceCategories.length} service categories, ${serviceTypes.length} service types`);

    // Step 3: Create Appointment (following frontend data structure)
    console.log('\nğŸ“… Step 3: Creating appointment...');
    const today = new Date();
    const currentTimestamp = today.toISOString().slice(0, 19).replace('T', ' '); // YYYY-MM-DD HH:mm:ss format
    
    const appointmentData = {
      subject: TEST_DATA.patient,                    // Patient CPF
      locationid: TEST_DATA.location,               // Location identifier  
      status: "booked",                             // Always "booked" for new appointments
      practitionerid: TEST_DATA.practitioner,      // Practitioner email/ID
      startdate: today.toISOString().split('T')[0], // YYYY-MM-DD format
      starttime: "09:00:00",                        // HH:mm:ss format
      duration: "60",                               // Duration in minutes (string)
      description: "Test appointment for in-progress encounter testing", // Appointment description/reason
      note: "Generated by create-test-encounter.js script",              // Internal notes
      created: currentTimestamp,                    // Creation timestamp (YYYY-MM-DD HH:mm:ss)
      servicecategory: firstServiceCategory,       // Service category ID
      servicetype: firstServiceType,               // Service type ID
      appointmenttype: "ROUTINE",                   // Appointment type
      selected_services: [                         // Array of services
        {
          id: "1",
          name: "Consulta MÃ©dica",
          price: "100.00",
          duration: 60
        }
      ],
      paymentType: "direct",                        // Payment type
      selectedPractCarePlanIdForAppointment: null, // Care plan ID if applicable
      selectedPatientCarePlanCode: null,           // Patient care plan code
      servicesCoverageStatus: []                   // Coverage status array
    };

    const appointmentResponse = await axios.post(
      `${BASE_URL}/appointment/create-appointment`,
      appointmentData,
      { headers }
    );

    const appointmentId = appointmentResponse.data.appointmentId || appointmentResponse.data.identifier;
    console.log(`âœ… Appointment created with ID: ${appointmentId}`);

    // Step 4: Start Encounter from Appointment (following frontend logic)
    console.log('\nğŸ¥ Step 4: Starting encounter...');
    
    // Get next encounter ID (like frontend does)
    const nextIdResponse = await axios.get(
      `${BASE_URL}/getNextId/ENC`,
      { headers }
    );
    const encounterId = nextIdResponse.data.nextval || nextIdResponse.data.nextId || nextIdResponse.data;
    console.log(`âœ… Generated encounter ID: ${encounterId}`);
    
    // Create encounter data payload (following frontend structure)
    const encounterStartTime = new Date();
    const encounterDataPayload = {
      Appointment: appointmentId,
      Identifier: encounterId,
      Note: null,
      Class: "AMB",
      Priority: "R",
      Length: 3600, // 1 hour in seconds
      Status: "in-progress",
      Subject: TEST_DATA.patient,
      Practitioner: TEST_DATA.practitioner,
      actualStart: encounterStartTime.toISOString().slice(0, 19).replace('T', ' '), // YYYY-MM-DD HH:mm:ss format
      actualEnd: null
    };

    // Save encounter info (like frontend does) 
    const requestBody = {
      encounterData: encounterDataPayload,
      wholeEncInfo: null // Add this as the frontend might send it
    };
    
    console.log('ğŸ“¤ Sending encounter data:', JSON.stringify(requestBody, null, 2));
    
    const encounterResponse = await axios.post(
      `${BASE_URL}/encounter/saveencounterinfo`,
      requestBody,
      { headers }
    );
    
    console.log(`âœ… Encounter saved with status: ${encounterResponse.status}`);

    // Step 5: Ensure Encounter Status is In-Progress
    console.log('\nâ³ Step 5: Setting encounter to in-progress status...');
    try {
      await axios.put(
        `${BASE_URL}/encounter/updatestatus/${encounterId}`,
        {
          status: 'in-progress',
          actualStart: new Date().toISOString()
        },
        { headers }
      );
      console.log('âœ… Encounter status updated to in-progress');
    } catch (error) {
      console.log('âš ï¸  Status update not needed or encounter already in-progress');
    }

    // Step 6: Verification
    console.log('\nğŸ” Step 6: Verifying created data...');
    
    // Check the appointment
    const appointmentCheck = await axios.get(
      `${BASE_URL}/appointment/getnextappointments/${TEST_DATA.practitioner}?days=7`,
      { headers }
    );
    console.log(`âœ… Found ${appointmentCheck.data?.length || 0} upcoming appointments`);

    // Check in-progress encounters
    const statusFilter = encodeURIComponent(JSON.stringify({
      filter1: 'in-progress',
      filter2: 'on-hold',
      filter3: ''
    }));
    
    const encounterCheck = await axios.get(
      `${BASE_URL}/encounter/getencounters/practitioner/${TEST_DATA.practitioner}?status=${statusFilter}`,
      { headers }
    );
    
    const encountersCount = encounterCheck.data?.data?.length || 0;
    console.log(`âœ… Found ${encountersCount} in-progress/on-hold encounters`);

    if (encountersCount > 0) {
      console.log('\nğŸ“‹ In-progress encounters:');
      encounterCheck.data.data.forEach((enc, index) => {
        console.log(`  ${index + 1}. ${enc.Identifier} - Status: ${enc.Status} - Patient: ${enc.Subject}`);
      });
    }

    console.log('\nğŸ‰ SUCCESS! Test encounter workflow completed successfully!');
    console.log(`ğŸ“„ Summary:`);
    console.log(`   - Appointment ID: ${appointmentId}`);
    console.log(`   - Encounter ID: ${encounterId}`);
    console.log(`   - Status: in-progress`);
    console.log(`   - Patient: ${TEST_DATA.patient} (MANOEL AUGUSTO RODRIGUES FOZ)`);
    console.log(`   - Practitioner: ${TEST_DATA.practitioner}`);
    console.log(`   - Ready for mobile app testing! ğŸ“±`);
    
    return {
      appointmentId,
      encounterId,
      success: true
    };

  } catch (error) {
    console.error('\nâŒ ERROR in workflow:');
    console.error('Message:', error.message);
    if (error.response) {
      console.error('Status:', error.response.status);
      console.error('Data:', error.response.data);
    }
    return { success: false, error };
  }
}

// Additional function to create multiple test encounters
async function createMultipleTestEncounters(count = 3) {
  console.log(`ğŸ”„ Creating ${count} test encounters for comprehensive testing...\n`);
  
  const results = [];
  for (let i = 0; i < count; i++) {
    console.log(`\n--- Creating Test Encounter ${i + 1}/${count} ---`);
    const result = await createTestInProgressEncounter();
    results.push(result);
    
    if (i < count - 1) {
      console.log('\nâ±ï¸  Waiting 2 seconds before next encounter...');
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  
  const successful = results.filter(r => r.success).length;
  console.log(`\nğŸ BATCH COMPLETE: ${successful}/${count} encounters created successfully!`);
  
  return results;
}

// Main execution
if (require.main === module) {
  const args = process.argv.slice(2);
  const command = args[0];
  
  if (command === 'multiple') {
    const count = parseInt(args[1]) || 3;
    createMultipleTestEncounters(count);
  } else {
    createTestInProgressEncounter();
  }
}

module.exports = {
  createTestInProgressEncounter,
  createMultipleTestEncounters
};